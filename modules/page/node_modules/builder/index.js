'use strict';

var $ = require('elements'),
	forOwn = require('mout/object/forOwn'),
	indexOf = require('mout/array/indexOf'),
	blocks = require('./blocks'),
	templates = require('./templates');

var Builder = function(){
	if (!(this instanceof Builder)) return new Builder();
	this.blockIds = {};
	this.blockId = 0;
	this.build();
	this.createBlocks();
	this.setEvents();
};

require('inherits')(Builder, require('events').EventEmitter);

/**
 *
 */
Builder.prototype.build = function(){
	this.wrap = document.createElement('div');
	this.wrap.classList.add('builder');
	this.wrap.innerHTML = '<div class="builder--template">' +
			'<div class="builder--empty-layout">' +
				'Choose a template to start building' +
			'</div>' +
		'</div>' +
		'<div class="builder--block-types">' +
			'<ul></ul>' +
		'</div>';

	this.blockWrapper = this.wrap.querySelector('.builder--block-types ul');
	this.template = this.wrap.querySelector('.builder--template');

	this.placeholder = document.createElement('div');
	this.placeholder.classList.add('builder--placeholder');
};

/**
 *
 */
Builder.prototype.createBlocks = function(){
	var sorted = [];
	forOwn(blocks, function(block, key){
		block.meta.key = key;
		sorted.push(block);
	});
	sorted.sort(function(a, b){
		if (a.meta.name > b.meta.name) return 1;
		else if (a.meta.name < b.meta.name) return -1;
		return 0;
	});

	var i, li;
	for (i = 0; i < sorted.length; i++){
		li = document.createElement('li');
		li.setAttribute('data-block-type', sorted[i].meta.key);
		li.setAttribute('draggable', true);
		li.innerHTML = '<span class="block-name">' + sorted[i].meta.name + '</span>' +
			'<span class="block-description">' + sorted[i].meta.description + '</span>';
		this.blockWrapper.appendChild(li);
	}
};

Builder.prototype.cacheZones = function(){
	this.zones = {};
	var zones = this.template.querySelectorAll('.zone'),
		i, len = zones.length, zone;

	for (i = 0; i < len; i++){
		zone = zones[i].getAttribute('data-zone');
		if (!zone) continue;

		this.zones[zone] = zones[i];
	}
};

/**
 * Set all required drag events
 */
Builder.prototype.setEvents = function(){
	var self = this, isHeader;

	// drag block
	this.blockWrapper.addEventListener('dragstart', function(e){
		var target = e.target || e.srcElement,
			blockType = target.getAttribute('data-block-type');

		if (!blockType) return;

		e.dataTransfer.dropEffect = 'copy';
		e.dataTransfer.setData('text', blockType);

		self.emit('block:dragstart', blockType, true);
	});

	// end drag block
	document.body.addEventListener('dragend', function(e){
		self.emit('block:dragend');
		if (self.hoverZone) self.emit('zone:leave', self.hoverZone);
	});

	// indicate that the zones are droppable
	this.template.addEventListener('dragover', function(e){
		e.preventDefault(); // required for anything to be droppable at all
	});

	// check the entire body for dragovers otherwise sometimes leaving a zone is not detected
	document.body.addEventListener('dragover', function(e){
		if (!self.dragging) return;

		var zone = self.getZone(e.target || e.srcElement);
		if (!zone){
			if (self.hoverZone){
				self.emit('zone:leave', self.hoverZone, self.isNewBlock);
			}
			return;
		}

		var zoneName = zone.getAttribute('data-zone');
		if (zoneName != self.hoverZone){
			if (self.hoverZone){
				self.emit('zone:leave', self.hoverZone, self.isNewBlock);
			}
			self.emit('zone:enter', zoneName);
		}
	});

	// enter zone
	this.template.addEventListener('dragenter', function(e){
		if (!self.dragging) return;

		e.preventDefault();

		var target = e.target || e.srcElement,
			zone = self.getZone(target);

		if (!zone) return;

		var isPlaceholder = target == self.placeholder;
		if (isPlaceholder) return;

		var block = target;

		if (!block.classList.contains('.block')){
			block = $(target).parent('.block');
			if (!block) return;

			block = block[0];
		}

		var placeholderIndex = indexOf(zone.childNodes, self.placeholder),
			blockIndex = indexOf(zone.childNodes, block),
			method = 'after';

		if (placeholderIndex == -1){
			return;
		}

		if (placeholderIndex > blockIndex){
			method = 'before';
		}
		$(self.placeholder)[method](block);
	});

	this.template.addEventListener('mousedown', function(e){
		var target = e.target || e.srcElement;
		if (target.classList.contains('block--header')){
			isHeader = true;
		}
	});

	// dragging existing blocks
	this.template.addEventListener('dragstart', function(e){
		var target = e.target || e.srcElement;
		if (!isHeader){
			e.preventDefault();
			return;
		}
		e.dataTransfer.setData('text', target.dataset.blockType);
		isHeader = false;
		self.dragBlock = target;
		self.emit('block:dragstart', target.dataset.blockType);

		// this delay is needed cause the dragImage won't be created properly otherwise
		setTimeout(function(){
			var rect = self.dragBlock.getBoundingClientRect();
			self.placeholder.style.height = (rect.bottom - rect.top) + 'px';
			self.dragBlock.parentNode.insertBefore(self.placeholder, self.dragBlock);
			self.dragBlock.style.display = 'none';
		}, 1);
	});


	var dragBlockType;

	/**
	 * Block starts dragging
	 * @param {String} type
	 * @param {Boolean} isNew
	 */
	this.on('block:dragstart', function(type, isNew){
		dragBlockType = type;
		self.dragging = true;
		self.isNewBlock = isNew;

		var block = blocks[type];
		forOwn(self.zones, function(zone, zoneName){
			if (!block.meta.constrain || block.meta.constrain.test(self.templateName + '.' + zoneName)){
				zone.classList.add('is-droppable');
				zone.dataset.droppable = true;
			} else {
				zone.classList.add('is-not-droppable');
			}
		});
	});

	/**
	 * Block stops dragging
	 */
	this.on('block:dragend', function(){
		var zone, block;
		if (self.targetZone){
			zone = self.zones[self.targetZone];
			if (self.isNewBlock){
				block = self.addBlock(self.targetZone, dragBlockType);
				zone.insertBefore(block.wrapper, self.placeholder);
				zone.removeChild(self.placeholder);
			} else {
				zone.insertBefore(self.dragBlock, self.placeholder);
				self.dragBlock.style.display = 'block';
				zone.removeChild(self.placeholder);
			}
		}

		dragBlockType = undefined;
		self.dragging = false;
		self.isNewBlock = false;
		self.targetZone = undefined;

		forOwn(self.zones, function(zone, zoneName){
			zone.classList.remove('is-droppable');
			zone.classList.remove('is-not-droppable');
			delete zone.dataset.droppable;
		});
	});

	/**
	 * Block enters zone
	 * @param {String} zoneName
	 */
	this.on('zone:enter', function(zoneName){
		var zone = self.zones[zoneName];
		if (!zone) return;

		self.hoverZone = zoneName;

		if (!zone.dataset.droppable){
			zone.classList.add('dragover-not-droppable');
			return;
		}

		zone.classList.add('dragover-droppable');
		self.targetZone = zoneName;

		if (indexOf(zone.childNodes, self.placeholder) == -1){
			zone.appendChild(self.placeholder);
		}
	});

	/**
	 * Block leaves zone
	 * @param {String} zoneName
	 */
	this.on('zone:leave', function(zoneName, isNew){
		var zone = self.zones[zoneName];
		if (!zone) return;

		if (isNew){
			if (zone.dataset.droppable){
				zone.removeChild(self.placeholder);
				self.placeholder.style.height = '';
			}
			self.targetZone = undefined;
		}

		zone.classList.remove('dragover-not-droppable');
		zone.classList.remove('dragover-droppable');
		self.hoverZone = undefined;
	});
};

/**
 * Retrieve the zone for any given element
 * @param {Element} el
 */
Builder.prototype.getZone = function(el){
	var zoneName = el.getAttribute('data-zone');
	if (zoneName) return el;

	var parent = $(el).parent('[data-zone]');
	if (parent) return parent[0];
};

/**
 * Add block of given type to given zone
 * @param {String} zoneName
 * @param {String} type
 * @param {String} style
 * @param {Object} data
 */
Builder.prototype.addBlock = function(zoneName, type, style, data){
	if (!blocks[type]){
		return console.error('Undefined block type `%s`', type);
	}

	var block = new blocks[type](style, data),
		zone = this.zones[zoneName],
		blockId = this.blockId++;

	block.wrapper.setAttribute('data-block-id', blockId);
	block.wrapper.setAttribute('data-block-type', type);
	zone.appendChild(block.wrapper);

	this.blockIds[blockId] = block;

	return block;
};

/**
 * Set page template to use
 * @param {String} name
 */
Builder.prototype.setTemplate = function(name){
	if (!name){
		this.template.innerHTML = '<div class="builder--empty-layout">' +
			'Choose a template to start building' +
		'</div>';
		this.zones = {};

		return;
	}
	this.templateName = name;
	this.template.innerHTML = templates[name];
	this.cacheZones();
};

/**
 * Serialize values from all blocks in the correct zones and block order
 * @return {Object}
 */
Builder.prototype.getValues = function(){
	var self = this, blocks, i, zones = {};
	forOwn(this.zones, function(zone, zoneName){
		zones[zoneName] = [];
		blocks = zone.querySelectorAll('.block');
		for (i = 0; i < blocks.length; i++){
			zones[zoneName].push(self.blockIds[blocks[i].getAttribute('data-block-id')].getValues());
		}
	});

	return zones;
};

module.exports = Builder;
